{
    "isUpdateAvailable": false,
    "isCustom": false,
    "isEnabled": false,
    "isRemoteConnector": false,
    "environment": "B",
    "integration": "MicrosoftGraphMailDelegated",
    "identifier": "Microsoft Graph Mail Delegated Connector_1d6b6d4d-9549-40be-b261-8aa4882fde00",
    "connectorDefinitionName": "Microsoft Graph Mail Delegated Connector",
    "displayName": "Microsoft Graph Mail Delegated Connector",
    "description": "Connector can be used to fetch emails from the Microsoft Graph Mail service. Connector dynamic list can be used to filter specific values from the email body and subject parts using regexes. By default, regex is used to filter out the urls from the email. This connector uses Delegated Authentication in Microsoft 365 and requires interactive login of the user on behalf of which integration should communicate with Microsoft 365. To configure the connector, make sure that the integration configuration is already finished, and the refresh token needed to communicate with Office 365 is generated.",
    "runIntervalInSeconds": 10,
    "resultDataType": 0,
    "version": "1",
    "pythonVersion": 3,
    "isAllowlistSupported": true,
    "params": [
        {
            "connectorIdentifier": null,
            "paramName": "Environment Field Name",
            "paramValue": "",
            "description": "The name of the field where the environment name is stored. If the environment field isn't found, the environment is the default environment. The default value is \"\"\n",
            "type": 2,
            "mode": 0,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Environment Regex Pattern",
            "paramValue": ".*",
            "description": "A regular expression pattern to run on the value found in the Environment Field Name field. This parameter lets you manipulate the environment field using the regular expression logic. Use the default value .* to retrieve the required raw Environment Field Name value. If the regular expression pattern is null or empty, or the environment value is null, the final environment result is the default environment.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Email Exclude Pattern",
            "paramValue": "",
            "description": "A regular expression to exclude specific emails from ingestion, such as spam or news. This parameter works with both the subject and body of the email.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Script Timeout (Seconds)",
            "paramValue": "300",
            "description": "The timeout limit in seconds for the Python process that runs the current script.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Microsoft Entra ID Endpoint",
            "paramValue": "https://login.microsoftonline.com",
            "description": "The Microsoft Entra endpoint to connect to. The default value is https://login.microsoftonline.com.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Microsoft Graph Endpoint",
            "paramValue": "https://graph.microsoft.com",
            "description": "The Microsoft Graph endpoint to connect to. The default value is https://graph.microsoft.com.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Mail Address",
            "paramValue": "labops1@siemplifycyarx.onmicrosoft.com",
            "description": "An email address for the connector to use.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Refresh Token",
            "paramValue": "***************",
            "description": "The refresh token that you obtained after you generated a token.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Client ID",
            "paramValue": "f994818c-540d-4813-8732-dfd434cdb6f1",
            "description": "For Microsoft 365 OAuth 2.0 authentication, the application (client) ID of the Microsoft Entra application that is used in the integration.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Client Secret Value",
            "paramValue": "***************",
            "description": "For Microsoft 365 OAuth 2.0 authentication, the client secret value that is provided for the authentication flow.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Microsoft Entra ID Directory ID",
            "paramValue": "d48f52ca-5b1a-4708-8ed0-ebb98a26a46a",
            "description": "For Microsoft 365 OAuth authentication, the tenant (directory) ID of the Microsoft Entra ID application that you used in the integration.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Folder To Check For Emails",
            "paramValue": "Inbox",
            "description": "An email folder to search for the emails. This parameter accepts a comma-separated list of folders to check the user response in multiple folders. To specify a subfolder, use the \u201c/\u201d forward slash, such as {Inbox/Subfolder}. This parameter is case-sensitive. The default value is Inbox.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Offset Time In Hours",
            "paramValue": "24",
            "description": "The number of hours before the first connector iteration to retrieve the incidents from. This parameter applies to the initial connector iteration after you enable the connector for the first time. The connector can use this parameter as a fallback value when the timestamp from the latest connector iteration expires.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Max Emails Per Cycle",
            "paramValue": "10",
            "description": "The maximum number of emails to fetch for every connector iteration.",
            "type": 1,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": true,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Unread Emails Only",
            "paramValue": "false",
            "description": "If selected, the connector creates cases only for unread emails.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Mark Emails as Read",
            "paramValue": "false",
            "description": "If selected, the connector marks ingested emails as read.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Disable Overflow",
            "paramValue": "false",
            "description": "If selected, the connector ignores the Google SecOps overflow mechanism.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Verify SSL",
            "paramValue": "false",
            "description": "If selected, the integration verifies that the SSL certificate for connecting to the Microsoft Graph server is valid.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Base64 Encoded Private Key",
            "paramValue": "",
            "description": "Specify a base64 encoded private key that will be used to decrypt the email.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Base64 Encoded Certificate",
            "paramValue": "",
            "description": "Specify a base64 encoded certificate that will be used to decrypt the email.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Base64 Encoded CA certificate",
            "paramValue": "",
            "description": "Specify a base64 encoded trusted CA certificate for signature verification.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Mail Field Source",
            "paramValue": "true",
            "description": "If selected, the connector retrieves the mailbox address from the user details \u201cmail\u201d attribute. If not selected, the integration retrieves the mailbox address from the \u201cuserPrincipalName\u201d field. Selected by default.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": false,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Original Received Mail Prefix",
            "paramValue": "orig",
            "description": "A prefix to add to the extracted event keys (for example, to, from, or subject) from the original email received in the monitored mailbox. The default value is orig.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Attached Mail File Prefix",
            "paramValue": "attach",
            "description": "A prefix to add to the extracted event keys (for example, to, from, or subject) from the attached email file received in the monitored mailbox. The default value is attach.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Create a Separate Google SecOps Alert Per Attached Mail File",
            "paramValue": "false",
            "description": "If selected, the connector creates multiple alerts, with one alert for every attached email file. This behavior is useful when you process emails with multiple email files attached and set the Google SecOps event mapping to create entities from attached email files.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Attach Original EML",
            "paramValue": "false",
            "description": "If selected, the connector attaches the original email to the case info as an EML file.",
            "type": 0,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Headers to add to events",
            "paramValue": "",
            "description": "A comma-separated string of email headers to add to Google SecOps events, such as \u201cDKIM-Siganture\u201d, \u201cReceived\u201d, \u201cFrom\u201d. You can provide an exact match for headers or set this parameter value as a regular expression. The connector filters the configured values from the \u201cinternetMessageHeaders\u201d list and adds them to the Google SecOps event. By default, the connector adds all available headers. To prevent the connector from adding headers to the event, set the parameter value as follows: None.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Case Name Template",
            "paramValue": "",
            "description": "A custom case name. When you configure this parameter, the connector adds a new key called custom_case_name to the Google SecOps event. You can provide placeholders in the following format: [name of the field]. Example: Phishing - [event_mailbox]. For placeholders, the connector uses the first Google SecOps event. The connector only handles keys that contain the string value.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Alert Name Template",
            "paramValue": "",
            "description": "A custom alert name. You can provide placeholders in the following format: [name of the field]. Example: Phishing - [event_mailbox]. For placeholders, the connector uses the first Google SecOps event. The connector only handles keys that contain the string value. If you configure an invalid template or don't set a value, the connector uses the default alert name.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Server Address",
            "paramValue": "",
            "description": "The address of the proxy server to use.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Username",
            "paramValue": "",
            "description": "The proxy server username to authenticate with.",
            "type": 2,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        },
        {
            "connectorIdentifier": null,
            "paramName": "Proxy Password",
            "paramValue": "",
            "description": "The proxy password to authenticate with.",
            "type": 3,
            "mode": 2,
            "isDisplayed": true,
            "isMandatory": false,
            "isAdvanced": true,
            "id": 0,
            "creationTimeUnixTimeInMs": 0,
            "modificationTimeUnixTimeInMs": 0
        }
    ],
    "allowList": [],
    "integrationVersion": 10.0,
    "isScriptConnector": true,
    "script": "from __future__ import annotations\n\nimport base64\nimport os\nfrom pathlib import Path\nimport re\nimport sys\nimport uuid\nfrom collections import defaultdict\nfrom collections.abc import Iterable\nfrom extract_msg.exceptions import InvalidFileFormatError\n\nfrom SiemplifyConnectorsDataModel import AlertInfo, CaseInfo\nfrom SiemplifyDataModel import Attachment\n\nfrom TIPCommon.base.connector import Connector\nfrom TIPCommon.consts import TIMEOUT_THRESHOLD\nfrom TIPCommon.data_models import BaseAlert\nfrom TIPCommon.exceptions import ParameterExtractionError, SMIMEMailError\nfrom TIPCommon.smp_io import read_ids, write_ids\nfrom TIPCommon.smp_time import (\n    convert_datetime_to_unix_time,\n    get_last_success_time,\n    is_approaching_timeout,\n    unix_now,\n)\nfrom TIPCommon.transformation import string_to_multi_value\nfrom TIPCommon.types import SingleJson\nfrom TIPCommon.utils import is_test_run, is_overflowed\n\nfrom EmailUtils import EmailUtils, get_html_urls\nfrom EnvironmentCommon import GetEnvironmentCommonFactory\n\nimport AuthenticationManager as auth_manager\nimport MicrosoftGraphMailDelegatedManager as api_manager\nfrom MicrosoftGraphMailDelegatedParser import create_eml_object\n\nfrom constants import (\n    CASE_NAME_PATTERN,\n    EVENT_ATTACHMENT_CONTENT_TYPE_MAP,\n    KEYS_TO_EXCEPT_ON_TRANSFORMATION,\n    PRIORITY_DEFAULT,\n    SMIME_ATTACHMENT_CONTENT_TYPES,\n    STORED_IDS_LIMIT,\n    EMPTY_EMAIL_SUBJECT,\n)\nfrom datamodels import MicrosoftGraphEmail, MicrosoftGraphFileAttachment, SmimeAuth\nfrom exceptions import InvalidAttachment\nfrom utils import (\n    create_siemplify_case_wall_attachment_object,\n    transform_dict_keys,\n    transform_template_string,\n    validate_b64_certificate,\n)\n\nCONNECTOR_NAME = \"Microsoft Graph Mail Delegated Connector\"\nCONNECTOR_STARTING_TIME = unix_now()\n\n\nclass MicrosoftGraphMailDelegatedConnector(Connector):\n\n    def __init__(self, _is_test: bool) -> None:\n        super().__init__(CONNECTOR_NAME, _is_test)\n        self.manager: api_manager.ApiManager | None = None\n        self.regex_map = self._build_regex_map(self.siemplify.whitelist)\n        self.email_utils = EmailUtils(logger=self.logger)\n\n    def validate_params(self):\n        \"\"\"Validate connector parameters.\"\"\"\n        self.params.max_email_per_cycle = self.param_validator.validate_positive(\n            param_name=\"Max Emails Per Cycle\",\n            value=self.params.max_emails_per_cycle,\n        )\n        self.params.offset_time_in_hours = self.param_validator.validate_non_negative(\n            param_name=\"Offset Time In Hours\",\n            value=self.params.offset_time_in_hours,\n        )\n        validate_b64_certificate(\n            param_name=\"Base64 Encoded Private Key\",\n            param_value=self.params.base64_encoded_private_key,\n        )\n        validate_b64_certificate(\n            param_name=\"Base64 Encoded Certificate\",\n            param_value=self.params.base64_encoded_certificate,\n        )\n        validate_b64_certificate(\n            param_name=\"Base64 Encoded CA certificate\",\n            param_value=self.params.base64_encoded_ca_certificate,\n        )\n        self.params.headers_to_add_to_events = string_to_multi_value(\n            self.params.headers_to_add_to_events,\n            only_unique=True\n        )\n\n    def init_managers(self) -> None:\n        \"\"\"Initializes the API client manager.\"\"\"\n        auth_params = auth_manager.SessionAuthenticationParameters(\n            azure_ad_endpoint=self.params.microsoft_entra_id_endpoint,\n            client_id=self.params.client_id,\n            client_secret=self.params.client_secret_value,\n            tenant=self.params.microsoft_entra_id_directory_id,\n            refresh_token=self.params.refresh_token,\n            verify_ssl=self.params.verify_ssl,\n        )\n        session = auth_manager.get_authenticated_session(auth_params)\n        api_params = api_manager.ApiParameters(\n            api_root=self.params.microsoft_graph_endpoint,\n            client_id=self.params.client_id,\n            client_secret=self.params.client_secret_value,\n            tenant=self.params.microsoft_entra_id_directory_id,\n            mail_address=self.params.mail_address,\n        )\n        self.manager = api_manager.ApiManager(\n            session=session,\n            api_parameters=api_params,\n            mail_field_source=self.params.mail_field_source,\n            logger=self.logger,\n        )\n        mail_address = self.manager.get_user_mailbox(self.params.mail_address)\n        self.manager.mail_address = mail_address\n\n        return self.manager\n\n    def read_context_data(self) -> None:\n        self.logger.info(\"Reading already existing alerts ids...\")\n        self.context.existing_ids = read_ids(self.siemplify)\n\n    def get_last_success_time(self) -> int:\n        return get_last_success_time(\n            self.siemplify,\n            offset_with_metric={\"hours\": self.params.offset_time_in_hours},\n        )\n\n    def set_last_success_time(\n        self, alerts: Iterable[MicrosoftGraphEmail], **kwargs\n    ) -> None:\n        \"\"\"Set connector's last success time.\"\"\"\n        super().set_last_success_time(\n            alerts=alerts,\n            timestamp_key=\"timestamp\",\n            **kwargs,\n        )\n\n    def get_alerts(self) -> Iterable[MicrosoftGraphEmail]:\n        \"\"\"Gets emails from the API manager.\"\"\"\n        self.logger.info(\n            f\"Successfully loaded {len(self.context.existing_ids)} existing ids\"\n        )\n        emails = self.manager.get_emails(\n            folder_name=self.params.folder_to_check_for_emails,\n            datetime_from=self.get_last_success_time(),\n            max_email_per_cycle=self.params.max_email_per_cycle,\n            existing_ids=self.context.existing_ids,\n            unread_only=self.params.unread_emails_only,\n            email_exclude_pattern=self.params.email_exclude_pattern,\n            connector_starting_time=CONNECTOR_STARTING_TIME,\n            script_timeout=self.params.python_process_timeout,\n        )\n\n        return emails[:1] if self.is_test_run else emails\n\n    def create_alert_info(self, alert: MicrosoftGraphEmail) -> AlertInfo:\n        \"\"\"Convert BaseAlert object to a Siemplify AlertInfo object.\n\n        Args:\n            alert: The BaseAlert object.\n\n        Returns:\n            AlertInfo: A Siemplify AlertInfo object.\n        \"\"\"\n        alert_info = AlertInfo()\n        alert_info.ticket_id = alert.identifier\n        alert_info.display_id = alert.identifier\n        alert_info.rule_generator = alert.rule_generator\n        alert_info.start_time = int(alert.start_time)\n        alert_info.end_time = int(alert.end_time)\n\n        return alert_info\n\n    def write_context_data(self, all_alerts: Iterable[MicrosoftGraphEmail]) -> None:\n        \"\"\"Write connector's context data.\"\"\"\n        if not all_alerts:\n            return\n\n        self.logger.info(\"Saving existing ids.\")\n        write_ids(\n            self.siemplify,\n            self.context.existing_ids,\n            stored_ids_limit=STORED_IDS_LIMIT,\n        )\n\n    def _disable_overflow_check(self, alerts: Iterable[CaseInfo]) -> bool:\n        \"\"\"Checks if an alert is overflowed and should be skipped based on\n            configuration settings.\n\n        Args:\n            alerts: Iterable of CaseInfo objects.\n\n        Return: True if the alert is overflowed and should be skipped, otherwise False.\n        \"\"\"\n        original_case = alerts[0]\n        alert_is_overflowed = not self.params.disable_overflow and is_overflowed(\n            self.siemplify,\n            original_case,\n            is_test_run,\n        )\n        if alert_is_overflowed:\n            self.logger.info(\n                f\"{original_case.rule_generator}-{original_case.ticket_id}-\"\n                f\"{original_case.environment}-{original_case.device_product}\"\n                f\" found as overflow alert. Skipping.\"\n            )\n        return alert_is_overflowed\n\n    def process_alerts(\n        self,\n        alerts: Iterable[MicrosoftGraphEmail],\n    ) -> tuple[Iterable[CaseInfo], Iterable[MicrosoftGraphEmail]]:\n        \"\"\"Processes fetched alerts.\"\"\"\n        processed_alerts = []\n        processed_email: Iterable[MicrosoftGraphEmail] = []\n        all_alerts = []\n\n        for alert in alerts:\n            try:\n                microsoft_graph_alert = alert\n                all_alerts.append(microsoft_graph_alert)\n                self.logger.info(\n                    f\"Starting to process alert {microsoft_graph_alert.id}\"\n                )\n\n                if is_approaching_timeout(\n                    self.params.python_process_timeout,\n                    CONNECTOR_STARTING_TIME,\n                    TIMEOUT_THRESHOLD,\n                ):\n                    self.logger.info(\n                        \"Timeout is approaching. Connector will gracefully exit\"\n                    )\n                    break\n\n                alert.mime_content = self.manager.load_email_content(email=alert)\n                alert.parsed_email = self._parse_eml(alert.id, alert.mime_content)\n                if alert.parsed_email is None:\n                    self.context.existing_ids.append(microsoft_graph_alert.id)\n                    continue\n                if alert.is_smime_email:\n                    self._set_smime_event_type_attachments(alert=alert)\n\n                processed_alert = self.process_alert(alert=microsoft_graph_alert)\n                disable_overflow = self._disable_overflow_check(processed_alert)\n                if disable_overflow:\n                    continue\n                if isinstance(processed_alert, (list, tuple)):\n                    processed_alerts.extend(processed_alert)\n                elif processed_alert:\n                    processed_alerts.append(processed_alert)\n\n                if self.is_test_run and processed_alerts:\n                    self.logger.info(\"Maximum alert count (1) for test run reached!\")\n                    break\n                self.context.existing_ids.append(microsoft_graph_alert.id)\n                processed_email.append(microsoft_graph_alert)\n\n            except Exception as e: # pylint: disable=broad-except\n                if hasattr(alert, \"id\"):\n                    alert_id_to_log = alert.id\n                elif hasattr(alert, \"alert_id\"):\n                    alert_id_to_log = alert.alert_id\n                else:\n                    alert_id_to_log = str(alert)\n\n                self.logger.error(\n                    f\"Failed to process alert with id {alert_id_to_log}: {e}\"\n                )\n                self.logger.exception(e)\n\n        self.manager.mark_emails_as_read(processed_email)\n\n        return processed_alerts, all_alerts\n\n    def _set_smime_event_type_attachments(self, alert: MicrosoftGraphEmail) -> None:\n        _, event_type_attachments = self._get_smime_attachments_from_parsed_alert(\n            alert.parsed_email[\"attachments\"]\n        )\n        self._set_smime_event_type_attachment_to_email(\n            alert=alert,\n            event_attachments=event_type_attachments,\n        )\n\n    def _set_smime_event_type_attachment_to_email(\n        self,\n        alert: MicrosoftGraphEmail,\n        event_attachments: list[tuple[str, bytes]],\n    ) -> None:\n        for attachment_name, attachment_content in event_attachments:\n            extension = Path(attachment_name).suffix.lower()\n            content_type = EVENT_ATTACHMENT_CONTENT_TYPE_MAP.get(extension)\n            if content_type:\n                attachment_object = self._get_attachment_object(\n                    attachment_name, attachment_content, content_type\n                )\n                getattr(alert, f\"{extension[1:]}_attachments\").append(attachment_object)\n\n    def _get_attachment_object(\n        self,\n        attachment_name: str,\n        attachment_content: bytes,\n        content_type: str,\n    ) -> MicrosoftGraphFileAttachment:\n        raw_data = {\n            \"@odata.type\": \"#microsoft.graph.fileAttachment\",\n            \"name\": attachment_name,\n            \"contentType\": content_type,\n        }\n        attachment = MicrosoftGraphFileAttachment(raw_data=raw_data, **raw_data)\n        attachment.content = attachment_content\n\n        return attachment\n\n    def _map_alerts_to_base_alerts(\n        self, emails: Iterable[MicrosoftGraphEmail]\n    ) -> Iterable[MicrosoftGraphEmail]:\n        \"\"\"Maps MicrosoftGraphEmail objects to BaseAlert objects.\"\"\"\n        base_alerts = []\n\n        for email in emails:\n            base_alert = BaseAlert(\n                raw_data=email.to_json(),\n                alert_id=email.id,\n            )\n            base_alerts.append(base_alert)\n        return base_alerts\n\n    def _build_regex_map(self, regex_list) -> SingleJson:\n        regex_map = {}\n        for regex_item in regex_list:\n            try:\n                if \": \" in regex_item:\n                    user_regex = regex_item.split(\": \", 1)\n                    if len(user_regex) >= 2:\n                        regex_map.update({user_regex[0]: user_regex[1]})\n            except (ValueError, AttributeError, IndexError) as e:\n                self.siemplify.logger.error(\n                    f\"Unable to get parse whitelist item {regex_item}. \"\n                    f\"Ignoring item and continuing.\"\n                )\n                self.siemplify.logger.exception(e)\n        return regex_map\n\n    def _extract_regex_from_content(self, email_subject, email_body) -> SingleJson:\n        \"\"\"Get urls, subject, from and to addresses from email body\n\n        Args:\n            email_subject: {str} email subject.\n            email_body: {str} email body.\n\n        Return: {dict} fields after parse.\n        \"\"\"\n        result_dictionary = {}\n        for key, regex_value in self.regex_map.items():\n            if regex_value:\n                regex_object = re.compile(regex_value)\n                all_results = regex_object.findall(email_body) + regex_object.findall(\n                    email_subject\n                )\n\n                for index, result in enumerate(all_results, 1):\n                    key_name = f\"{key}_{index}\"\n                    result_dictionary[key_name] = result\n\n        return result_dictionary\n\n    def _get_eml_attachments(\n        self,\n        email: MicrosoftGraphEmail,\n    ) -> Iterable[MicrosoftGraphFileAttachment]:\n        \"\"\"Get eml attachments.\n\n        Args:\n            email: {MicrosoftGraphEmail} Parse microsoft graph email.\n\n        Return: {list} EML attachments list exported from original message\n        \"\"\"\n        attachments = []\n\n        for eml_attachment in email.eml_attachments:\n            try:\n                self.logger.info(f\"Parsing EML: {eml_attachment.name}\")\n                parsed_eml = self._parse_eml(email.id, eml_attachment.content)\n                if not parsed_eml:\n                    continue\n\n                parsed_eml[\"attachments_md5_filehash\"] = eml_attachment.md5_hash()\n\n                attachments.append((eml_attachment.name, parsed_eml))\n\n            except (AttributeError, KeyError, TypeError, LookupError) as err:\n                self.logger.error(\"Failed Parsing EML content\")\n                self.logger.exception(err)\n\n        return attachments\n\n    def _parse_eml(self, alert_id: str, content: bytes) -> SingleJson | None:\n        try:\n            smime_auth = SmimeAuth(\n                private_key_b64=self.params.base64_encoded_private_key,\n                certificate_b64=self.params.base64_encoded_certificate,\n                ca_certificate_b64=self.params.base64_encoded_ca_certificate,\n            )\n            return self.email_utils.convert_siemplify_eml_to_connector_eml(\n                content,\n                headers_to_add=self.params.headers_to_add_to_events,\n                smime_auth=smime_auth,\n            )\n\n        except (ParameterExtractionError, SMIMEMailError, ValueError) as e:\n            self.logger.error(\n                f\"Failed to process SMIME email with message_id={alert_id}. \"\n                f\"Skipping. Error: {str(e)}\"\n            )\n\n        return None\n\n    def _get_msg_attachments(\n        self, email: MicrosoftGraphEmail\n    ) -> Iterable[MicrosoftGraphFileAttachment]:\n        \"\"\"Get msg attachments.\n\n        Args:\n            email: {MicrosoftGraphEmail} Parse microsoft graph email.\n\n        Return: {list} MSG attachments list exported from original message.\n        \"\"\"\n        parsed_attachments = []\n        for msg_attachment in email.msg_attachments:\n            try:\n                self.logger.info(f\"Parsing MSG: {msg_attachment.name}\")\n                parsed_msg = self.email_utils.convert_siemplify_msg_to_connector_msg(\n                    msg_attachment.content,\n                    headers_to_add=self.params.headers_to_add_to_events,\n                )\n                parsed_msg[\"attachments_md5_filehash\"] = msg_attachment.md5_hash()\n\n                parsed_attachments.append((msg_attachment.name, parsed_msg))\n\n            except (\n                AttributeError,\n                KeyError,\n                TypeError,\n                LookupError,\n                InvalidFileFormatError,\n            ) as err:\n                self.logger.error(\"Failed Parsing MSG content\")\n                self.logger.exception(err)\n\n        return parsed_attachments\n\n    def _get_ics_attachments(\n        self, email: MicrosoftGraphEmail\n    ) -> Iterable[MicrosoftGraphFileAttachment]:\n        \"\"\"Get ics attachments.\n\n        Args:\n            email: {MicrosoftGraphEmail} Parse microsoft graph email.\n\n        Return: {email} ICS attachments list exported from original message.\n        \"\"\"\n        parsed_attachments_data = []\n        for ics_attachment in email.ics_attachments:\n            try:\n                self.logger.info(f\"Parsing ICS: {ics_attachment.name}\")\n                parsed_ics_list = (\n                    self.email_utils.convert_siemplify_ics_to_connector_msg(\n                        ics_attachment.content\n                    )\n                )\n\n                if len(parsed_ics_list) > 1:\n                    file_name, file_extension = os.path.splitext(ics_attachment.name)\n                    for index, ics in enumerate(parsed_ics_list, 1):\n                        new_file_name = f\"{file_name}_{index}{file_extension}\"\n                        parsed_attachments_data.append((new_file_name, ics))\n                elif len(parsed_ics_list) == 1:\n                    parsed_attachments_data.append(\n                        (ics_attachment.name, parsed_ics_list[0])\n                    )\n\n            except (\n                ValueError,\n                TypeError,\n                AttributeError,\n                KeyError,\n                LookupError,\n            ) as err:\n                self.logger.error(\"Failed Parsing ICS content\")\n                self.logger.exception(err)\n\n        return parsed_attachments_data\n\n    def _attach_file_to_case(self, file_name, file_content):\n        self.logger.info(\"Checking EML and MSG attachments to attach to the case\")\n        try:\n            if isinstance(file_content, str):\n                file_content = file_content.encode()\n            self.logger.info(f\"Attached {file_name} file to the case\")\n            return create_siemplify_case_wall_attachment_object(file_name, file_content)\n\n        except (AttributeError, KeyError, TypeError) as e:\n            self.logger.error(f\"Failed to attach {file_name} to the case wall\")\n            self.logger.exception(e)\n\n        return None\n\n    def process_alert(self, alert: MicrosoftGraphEmail) -> CaseInfo:\n        \"\"\"Process the alert and generate cases based on the alert_per_attachment\n            setting.\n\n        Args:\n            alert (MicrosoftGraphEmail): The email alert object to be processed.\n\n        Returns:\n            CaseInfo: A list containing the created case(s)\n        \"\"\"\n        alert.content = alert.mime_content\n\n        if (\n            not\n            self.params.create_a_separate_google_sec_ops_alert_per_attached_mail_file\n        ):\n            return [\n                self._create_case(\n                    alert,\n                    self.params.attached_mail_file_prefix,\n                    self.params.original_received_mail_prefix,\n                    self.params.attach_original_eml,\n                )\n            ]\n\n        return self._create_cases(\n            alert,\n            self.params.attached_mail_file_prefix,\n            self.params.original_received_mail_prefix,\n            self.params.attach_original_eml,\n        )\n\n    def _get_item_attachments_data(self, email):\n        \"\"\"\n        Get attachments from message.\n        :param email: {MicrosoftGraphEmail} If True will load only unread emails.\n        :return: {list} Item attachments list exported from original message\n        \"\"\"\n        eml_attachments = self._get_eml_attachments(email)\n        msg_attachments = self._get_msg_attachments(email)\n        ics_attachments = self._get_ics_attachments(email)\n\n        self.logger.info(\n            f\"Found {len(eml_attachments)} EMLs, {len(msg_attachments)} MSGs and \"\n            f\"{len(ics_attachments)} ICSs for mail with ID: {email.id}\"\n        )\n\n        return eml_attachments + msg_attachments + ics_attachments\n\n    def _get_events_for_attachments(self, alert: MicrosoftGraphEmail, prefix=None):\n        \"\"\"\n        Create and return evens from original message attachments only EML/MSG/ICS.\n        :param alert: {MicrosoftGraphEmail} Parsed EML content.\n        :param prefix: {str} Prefix for events keys\n        :return: list , list events: Events list created from attachments, file_names:\n        list of file names only EML/MSG/ICS\n        \"\"\"\n        events = []\n        attachments = self._get_item_attachments_data(alert)\n        for _, value in enumerate(attachments):\n            parsed_email_filename, parsed_email = value\n            self.logger.info(f\"Processing parsed email: {parsed_email_filename}\")\n            parsed_email_body = parsed_email[\"body\"][\"content\"] or \"\"\n            parsed_email_subject = parsed_email[\"subject\"] or \"\"\n\n            additional_info = self._extract_regex_from_content(\n                email_subject=parsed_email_subject, email_body=parsed_email_body\n            )\n\n            urls, original_src_urls = get_html_urls(parsed_email_body)\n            additional_info.update({\"urls_from_html_part\": original_src_urls})\n            additional_info.update({\"visible_urls_from_html_part\": urls})\n\n            event_data = alert.create_event(\n                additional_info=additional_info, attachment_data=parsed_email\n            )\n            event_data = transform_dict_keys(\n                original_dict=event_data,\n                prefix=prefix,\n                keys_to_except=KEYS_TO_EXCEPT_ON_TRANSFORMATION,\n            )\n\n            events.append(event_data)\n        return events\n\n    def _create_case(\n        self,\n        alert: MicrosoftGraphEmail,\n        attached_mail_prefix: str,\n        original_mail_prefix: str,\n        attach_original_attachment: bool,\n    ) -> CaseInfo:\n        \"\"\"Create a case from the provided alert, including any associated attachment\n            events.\n\n        Args:\n            alert (MicrosoftGraphEmail): The email alert object to create a case from.\n            attached_mail_prefix (str): The prefix to use for events related to attached\n                mail.\n            original_mail_prefix (str): The prefix to use for the original mail.\n            attach_original_attachment (bool): Whether to attach the original email as\n                an attachment in the case.\n\n        Returns:\n            CaseInfo: The generated case information, including any events associated\n                with the attachments.\n        \"\"\"\n        attachment_events = self._get_events_for_attachments(\n            alert, attached_mail_prefix\n        )\n        case_info = self._generate_case_info(\n            alert=alert,\n            mail_prefix=original_mail_prefix,\n            attach_original_attachment=attach_original_attachment,\n        )\n\n        case_info.events.extend(attachment_events)\n        return case_info\n\n    def _create_cases(\n        self,\n        alert: MicrosoftGraphEmail,\n        attached_mail_prefix: str,\n        original_mail_prefix: str,\n        attach_original_attachment: bool,\n    ) -> CaseInfo:\n        \"\"\"Creates cases from an email alert and its attachments.\n\n        Args:\n            alert (MicrosoftGraphEmail): The email alert to process.\n            attached_mail_prefix (str): Prefix for the attachment cases.\n            original_mail_prefix (str): Prefix for the primary alert case.\n            attach_original_attachment (bool): Whether to attach the original email\n                to the case.\n            email_content (str | None): The content of the email body, if available.\n                Defaults to None.\n\n        Returns:\n            CaseInfo: A list of generated cases including the primary case and\n                attachment cases.\n        \"\"\"\n        case_info = self._generate_case_info(\n            alert=alert,\n            mail_prefix=original_mail_prefix,\n            attach_original_attachment=attach_original_attachment,\n        )\n        cases = [case_info]\n        item_attachments = self._get_item_attachments_data(alert)\n        for _, attachment_data in item_attachments:\n            attachment_case = self._generate_case_info(\n                alert=alert,\n                mail_prefix=attached_mail_prefix,\n                attachment_data=attachment_data,\n            )\n            attachment_case.events.append(case_info.events[0])\n            cases.append(attachment_case)\n        return cases\n\n    def _generate_case_info(\n        self,\n        alert: MicrosoftGraphEmail,\n        mail_prefix: str,\n        attachment_data: list[defaultdict] = None,\n        attach_original_attachment: bool = False,\n    ) -> CaseInfo:\n        \"\"\"Generates a CaseInfo object based on alert data.\"\"\"\n        additional_info = self._extract_additional_info(alert)\n        event_details = self._create_event_details(\n            alert, additional_info, attachment_data, mail_prefix\n        )\n\n        case_info = self._initialize_case_info(alert, event_details, attachment_data)\n        case_info.environment = self._get_environment(event_details)\n        case_info.events = [event_details]\n\n        if attach_original_attachment:\n            self._attach_original_email(case_info, alert)\n\n        return case_info\n\n    def _extract_additional_info(self, alert: MicrosoftGraphEmail) -> dict[str, str]:\n        \"\"\"Extracts additional info from email content.\"\"\"\n        text_body_content = alert.parsed_email[\"uniqueBody\"][\"content\"]\n        additional_info = self._extract_regex_from_content(\n            email_subject=alert.subject,\n            email_body=alert.body_content or text_body_content,\n        )\n        urls, original_src_urls = get_html_urls(alert.body_content or text_body_content)\n        additional_info.update(\n            {\n                \"urls_from_html_part\": original_src_urls,\n                \"visible_urls_from_html_part\": urls,\n            }\n        )\n        return additional_info\n\n    def _create_event_details(\n        self,\n        alert: MicrosoftGraphEmail,\n        additional_info: dict[str, str],\n        attachment_data: list[defaultdict],\n        mail_prefix: str,\n    ) -> dict[str, str]:\n        \"\"\"Creates event details with transformation.\"\"\"\n        event_details = alert.create_event(\n            additional_info=additional_info,\n            attachment_data=attachment_data,\n            headers_to_add_to_events=self.params.headers_to_add_to_events,\n        )\n\n        if self.params.case_name_template:\n            event_details[\"custom_case_name\"] = transform_template_string(\n                self.params.case_name_template, event_details\n            )\n\n        transformed_event_details = transform_dict_keys(\n            original_dict=event_details,\n            prefix=mail_prefix,\n            keys_to_except=KEYS_TO_EXCEPT_ON_TRANSFORMATION,\n        )\n        if (\n            self.params.case_name_template\n            and \"custom_case_name\" not in transformed_event_details\n        ):\n            transformed_event_details[\"custom_case_name\"] = transformed_event_details[\n                f\"{mail_prefix}_custom_case_name\"\n            ]\n\n        return transformed_event_details\n\n    def _initialize_case_info(\n        self,\n        alert: MicrosoftGraphEmail,\n        event_details: dict[str, str],\n        attachment_data: list[defaultdict],\n    ) -> CaseInfo:\n        \"\"\"Initializes a CaseInfo object with the given event details.\"\"\"\n        alert_name = transform_template_string(\n            self.params.alert_name_template, event_details\n        ) if self.params.alert_name_template else \"\"\n        case_info = CaseInfo()\n        case_info.name = alert_name or CASE_NAME_PATTERN.format(alert.mailbox_name)\n        case_info.rule_generator = case_info.name\n        case_info.start_time = convert_datetime_to_unix_time(alert.parsed_time)\n        case_info.end_time = convert_datetime_to_unix_time(alert.parsed_time)\n        case_info.identifier = alert.internet_message_id\n        case_info.ticket_id = f\"{alert.internet_message_id}_{int(alert.timestamp)}\"\n        case_info.display_id = (\n            f\"{alert.id}_{int(alert.timestamp)}\"\n            if attachment_data is None\n            else str(uuid.uuid4())\n        )\n        case_info.priority = PRIORITY_DEFAULT\n        case_info.device_vendor = event_details.get(\"device_vendor\", \"Unknown\")\n        case_info.device_product = event_details.get(\"device_product\", \"Unknown\")\n        case_info.attachments = self._extract_attachments(alert, attachment_data)\n        return case_info\n\n    def _extract_attachments(\n        self,\n        alert: MicrosoftGraphEmail,\n        attachment_data: list[defaultdict],\n    ) -> Iterable[Attachment]:\n        \"\"\"Extracts and attaches files to the case if needed.\"\"\"\n        attachments = []\n        if attachment_data is None:\n            for attachment in alert.file_attachments:\n                if (\n                    attachment.content_type in SMIME_ATTACHMENT_CONTENT_TYPES\n                    and alert.parsed_email[\"attachments\"]\n                ):\n                    attachment_data, _ = self._get_smime_attachments_from_parsed_alert(\n                        attachments_data=alert.parsed_email[\"attachments\"]\n                    )\n                else:\n                    attachment_data = [(attachment.name, attachment.content)]\n\n                for attachment_name, attachment_content in attachment_data:\n                    attachment_for_case = self._attach_file_to_case(\n                        attachment_name, attachment_content\n                    )\n\n                    if attachment_for_case:\n                        attachments.append(attachment_for_case)\n\n        return attachments\n\n    def _get_smime_attachments_from_parsed_alert(\n        self,\n        attachments_data: SingleJson,\n    ) -> tuple(list(tuple(str, bytes)), list(tuple(str, bytes))):\n        attachment_data = []\n        smime_event_type_attachments: list[tuple[str, bytes]] = []\n        index = 0\n        while True:\n            attachment_name: str | None = attachments_data.get(\n                f\"attachment_name_{index}\"\n            )\n            attachment_content_b64: str | None = attachments_data.get(\n                f\"base64_encoded_content_{index}\"\n            )\n\n            if attachment_name is None and attachment_content_b64 is None:\n                break\n\n            attachment_content: bytes = base64.b64decode(\n                attachment_content_b64.encode()\n            )\n            if self._is_event_type_attachment(attachment_name):\n                smime_event_type_attachments.append(\n                    (attachment_name, attachment_content)\n                )\n            else:\n                attachment_data.append((attachment_name, attachment_content))\n\n            index += 1\n\n        return attachment_data, smime_event_type_attachments\n\n    def _is_event_type_attachment(self, attachment_name: str) -> bool:\n        attachment_extension = attachment_name.split(\".\")[-1]\n        if attachment_extension in [\"ics\", \"msg\", \"eml\"]:\n            return True\n\n        return False\n\n    def _get_environment(self, event_details: dict[str, str]) -> str:\n        \"\"\"Retrieves the environment based on event details.\"\"\"\n        environment_common = GetEnvironmentCommonFactory.create_environment_manager(\n            siemplify=self.siemplify,\n            environment_field_name=self.params.environment_field_name,\n            environment_regex_pattern=self.params.environment_regex_pattern,\n        )\n        return environment_common.get_environment(event_details)\n\n    def _attach_original_email(self, case_info: CaseInfo, alert: MicrosoftGraphEmail):\n        \"\"\"Attaches the original email as an EML file to the case.\"\"\"\n        try:\n            attachment_object = create_eml_object(\n                original_email_content=alert.content,\n                attachment_name=alert.subject or EMPTY_EMAIL_SUBJECT,\n            )\n            case_info.attachments.append(attachment_object)\n            self.logger.info(\"Successfully attached original message as EML.\")\n        except InvalidAttachment as e:\n            self.logger.error(f\"Failed to attach original EML. Error: {e}.\")\n\n\nif __name__ == \"__main__\":\n    is_test = is_test_run(sys.argv)\n    connector = MicrosoftGraphMailDelegatedConnector(is_test)\n    connector.start()\n",
    "documentationLink": "https://cloud.google.com/chronicle/docs/soar/marketplace-integrations/microsoft-graph-mail-delegated#microsoft-graph-mail-delegated-connector",
    "deviceProductField": "device_product",
    "eventNameField": "event_name",
    "connectorStatus": null,
    "isNew": false,
    "agentIdentifier": null
}